#include "CFG.h"

#pragma region CONFIGS

void config1(CFG& x) {
    x.S = "S";
    x.N.insert("S"); x.N.insert("A"); x.N.insert("B");
    x.N.insert("C"); x.N.insert("D"); x.N.insert("F");
    x.T.insert("a"); x.T.insert("b"); x.T.insert("c");
    x.T.insert("#"); //lambda 
    x.P["S"].insert({ "a","A","b" }); x.P["S"].insert({ "B","C" }); x.P["S"].insert({ "#" });
    x.P["A"].insert({ "A","a","B" }); x.P["A"].insert({ "D","b" });
    x.P["B"].insert({ "b" }); x.P["B"].insert({ "c" });
    x.P["C"].insert({ "#" }); x.P["C"].insert({ "a","b" });
    x.P["D"].insert({ "#" }); x.P["F"].insert({ "a" });
}
void config2(CFG& x) {
    x.S = "S";
    x.T.insert("a"); x.T.insert("b"); x.T.insert("c"); x.T.insert("d");
    x.T.insert("e"); x.T.insert("f"); x.T.insert("g"); x.T.insert("#");
    x.N.insert("S"); x.N.insert("B"); x.N.insert("D"); x.N.insert("F");
    x.N.insert("G"); x.N.insert("H");
    x.P["S"].insert({ "a","B","c","D","e","F" }); x.P["S"].insert({ "H","F" });
    x.P["S"].insert({ "H","B","c" });
    x.P["B"].insert({ "b" }); x.P["B"].insert({ "#" }); x.P["D"].insert({ "d" });
    x.P["D"].insert({ "#" }); x.P["F"].insert({ "G" }); x.P["G"].insert({ "f" });
    x.P["G"].insert({ "g" }); x.P["H"].insert({ "#" });
}
void config3(CFG& x) {
    x.S = "S";
    x.T.insert("a"); x.T.insert("b"); x.T.insert("c"); x.T.insert("d");
    x.T.insert("#");
    x.N.insert("S"); x.N.insert("A"); x.N.insert("B"); x.N.insert("C");
    x.N.insert("D"); x.N.insert("E"); x.N.insert("F");
    x.P["S"].insert({ "a","A","B","a" }); x.P["S"].insert({ "C","D" }); x.P["S"].insert({ "b","b","A","C" });
    x.P["A"].insert({ "b","c" }); x.P["A"].insert({ "d" }); x.P["A"].insert({ "#" });
    x.P["B"].insert({ "#" }); x.P["B"].insert({ "E" }); x.P["C"].insert({ "A" });
    x.P["C"].insert({ "d","c","a","b","b" }); x.P["C"].insert({ "S" }); x.P["D"].insert({ "B","A","d" }); x.P["D"].insert({ "B" });
    x.P["E"].insert({ "E","a" }); x.P["E"].insert({ "b","b","E" }); x.P["F"].insert({ "a","b","c" });
}

#pragma endregion

CFG::CFG(const CFG& g) {
    this->N = g.N;
    this->T = g.T;
    this->S = g.S;
    this->P = g.P;
}

void CFG::printGrammar() {
    for (auto p : P) {
        cout << p.first << " -> ";
        for (auto rhs : p.second) {
            for (string s : rhs) {
                cout << s;
            }
            cout << " | ";
        }
        cout << endl;
    }
}

void CFG::toCNF() {
    step1();
    step2();
    step3();
    step1();
    step4();
    step5();
}

#pragma region CFG->CNF steps 

void CFG::step1() {
    removeUnusable();
    removeInaccessible();
}

void CFG::step2() {
    //firsly, we need to know if lambda is generated by the grammar, directly from S
    bool madeNewS = false;
    for (auto rhs : P[S]) {
        if (rhs[0] == "#" && rhs.size() == 1) {
            //if the start symbol has a lambda production
            //we make a new production S'-> S | lambda 
            //and S' becomes the new starting symbol
            string newS = "S'";
            P[S].erase({ "#" });
            P[newS].insert({ S });
            P[newS].insert({ "#" });
            S = newS;
            madeNewS = true;
            N.insert(S);
            break;
        }
    }
    while (hasLambda()) {
        map<string, set<vector<string>>>newP(P);
        for (auto p : newP) {
            //for each production
            for (auto rhs : p.second) {
                if (rhs[0] == "#" && rhs.size() == 1) {
                    if (p.second.size() == 1) {
                        //if it only has a lambda production
                        string lhs = p.first; //the lhs of the production
                        P.erase(lhs);//delete the whole production
                        //now we must remake the productions
                        //containing that non-terminal
                        for (auto p2 : P) {
                            set<vector<string>> newRHS;
                            for (auto rhs2 : p2.second) {
                                vector<string> replaceWith;
                                bool needsReplacement = false;
                                for (string s : rhs2) {
                                    if (s == lhs) {
                                        needsReplacement = true;
                                    }
                                    else {
                                        replaceWith.push_back(s);
                                    }
                                }
                                if (needsReplacement) {
                                    if (rhs2.size() == 1) {
                                        newRHS.insert({ "#" });
                                    }
                                    if (rhs2.size() >= 2) {
                                        newRHS.insert(replaceWith);
                                    }
                                }
                                else {
                                    newRHS.insert(rhs2);
                                }
                            }
                            P[p2.first] = newRHS;
                        }
                    }
                    if (p.second.size() > 1 && p.first != S) {
                        string lhs = p.first;
                        P[lhs].erase({ "#" }); //we only delete the lambda production
                        for (auto p2 : P) {
                            set<vector<string>> newRHS;
                            for (auto rhs2 : p2.second) {
                                vector<string> replaceWith;
                                bool needsReplacement = false;
                                for (string s : rhs2) {
                                    if (s != lhs) replaceWith.push_back(s); //this should contain the string that should substitute the old one
                                    if (s == lhs) {
                                        needsReplacement = true;
                                    }
                                }
                                if (needsReplacement) {
                                    newRHS.insert(rhs2);
                                    if (rhs2.size() >= 2) {
                                        newRHS.insert(replaceWith);
                                    }
                                    if (rhs2.size() == 1) {
                                        newRHS.insert({ "#" });
                                    }
                                }
                                else {
                                    newRHS.insert(rhs2);
                                }
                            }
                            P[p2.first] = newRHS;
                        }
                    }
                }
            }
        }

    }
    bool ShasLambda = false;
    bool SinRHS = false;
    for (auto rhs : P[S]) {
        for (string s : rhs) {
            if (s == "#" && rhs.size() == 1) {
                ShasLambda = true;
            }
        }
    }
    for (auto p : P) {
        for (auto rhs : p.second) {
            for (string s : rhs) {
                if (s == S) {
                    SinRHS = true;
                    break;
                }
            }
        }
    }
    //if the grammar generates lambda and S appears on the rhs of any production,
    //we create a new starting symbol
    if (ShasLambda && SinRHS) {
        string newS = "S'";
        P[S].erase({ "#" });
        P[newS].insert({ S });
        P[newS].insert({ "#" });
        S = newS;
        madeNewS = true;
        N.insert(S);
    }
}

void CFG::step3() {
    bool hasModified = true;
    //while (hasModified) {
    //    hasModified = false;
    for (auto p : P) {
        set<vector<string>>newRHS;
        for (auto rhs : p.second) {
            if (N.find(rhs[0]) != N.end() && rhs.size() == 1 && rhs[0] != p.first) {
                //if we found a production of type N1->N2
                //we must replace N2 with its productions
                for (auto rhs2 : P[rhs[0]]) {
                    newRHS.insert(rhs2);
                    hasModified = true;
                }
            }
            else {
                //if it is not of type N1->N2, we keep it
                newRHS.insert(rhs);
            }
        }
        P[p.first] = newRHS;
    }
    //printGrammar();
    //cout << endl;
//}
}

void CFG::step4() {
    //we will add non-terminals of type "Xnumber" where numbers starts from 1
    int number = 1;
    string X = "";
    map<string, string>substitution;//terminal->non-terminal
    for (auto p : P) {
        set<vector<string>> newRHS;
        for (auto rhs : p.second) {
            vector<string> newS;
            for (string s : rhs) {
                if (T.find(s) != T.end() && rhs.size() > 1) {
                    //if the rhs of the production has a minimum size of 2
                    //and contains terminals
                    if (substitution[s] == "") {
                        //if the substitution doesn't exist yet, we create it
                        X = "X" + to_string(number);
                        while (N.find(X) != N.end()) {
                            number++;
                            X = "X" + to_string(number);
                        }
                        N.insert(X);
                        substitution[s] = X;
                        P[X].insert({ s }); //we add it in the productions map
                    }
                    newS.push_back(substitution[s]);
                }
                else {
                    newS.push_back(s);
                }
            }
            newRHS.insert(newS);
        }
        P[p.first] = newRHS;
    }
}

void CFG::step5() {
    //we will add non-terminals of type "Ynumber" where numbers starts from 1
    int number = 1;
    string Y = "";
    map<vector<string>, string>substitution; //word containing non-terminals -> non-terminal
    bool hasModified = true;
    while (hasModified) {
        hasModified = false;
        for (auto p : P) {
            set<vector<string>>newRHS;
            for (auto rhs : p.second) {
                vector<string> newS;
                if (rhs.size() >= 3) {
                    hasModified = true;
                    vector<string>needsSub;
                    for (int i = 1; i < rhs.size(); i++) {
                        needsSub.push_back(rhs[i]);
                    }
                    string firstN = rhs[0];
                    if (substitution[needsSub] == "") {
                        //if the substitution doesn't exist yet, we create it
                        Y = "Y" + to_string(number);
                        while (N.find(Y) != N.end()) {
                            number++;
                            Y = "Y" + to_string(number);
                        }
                        N.insert(Y);
                        substitution[needsSub] = Y;
                        P[Y].insert(needsSub); //we add it in the productions map
                    }
                    //newS = firstN + substitution[needsSub];
                    newS.push_back(firstN);
                    newS.push_back(substitution[needsSub]);
                }
                else {
                    newS = rhs;
                }
                newRHS.insert(newS);
            }
            P[p.first] = newRHS;
        }
    }
}

#pragma endregion

#pragma region HELPERS

set<string> CFG::usableN() {
    //eliminating unusable symbols and productions
    set<string>usable; // usable non-terminals
    for (auto p : P) {
        //for each production
        bool use = false;
        bool every = true;
        for (auto rhs : p.second) {
            //for each right hand side of the production
            //if at least one is in T* or each symbol is in T* => the non-terminal is usable
            if (rhs.size() == 1 && T.find(rhs[0]) != T.end()) {
                use = true;
            }
            every = true;
            for (string s : rhs) {
                if (T.find(s) == T.end()) {
                    every = false;
                    break;
                }
            }
        }
        if (use || every) usable.insert(p.first);
    }
    bool modified = true;
    while (modified) {
        modified = false;
        for (auto p : P) {
            //for every production
            if (usable.find(p.first) == usable.end()) {
                //if the lhs was not usable before the last modification
                //we check if it is usable now
                bool every = true;
                for (auto rhs : p.second) {
                    every = true;
                    for (string s : rhs) {
                        if (T.find(s) == T.end() && usable.find(s) == usable.end()) {
                            every = false;
                            break;
                        }
                    }
                    if (every) {
                        usable.insert(p.first);
                        modified = true;
                    }
                }
            }
        }
    }
    return usable;
}

void CFG::removeUnusable() {
    set<string>usable = usableN();
    for (auto n : N) {
        //for each non-terminal
        if (usable.find(n) == usable.end()) {
            //if it s not usable
            //we must eliminate it and any production containing it on lfs/rhs
            P.erase(n);
            for (auto p : P) {
                //for each production
                set<vector<string>> newRHS;
                for (auto rhs : p.second) {
                    //for each rhs of the production
                    bool shouldBeRemoved = false;
                    for (string s : rhs) {
                        if (s == n) {
                            //if it contains n it should be removed
                            shouldBeRemoved = true;
                            break;
                        }
                    }
                    if (!shouldBeRemoved) {
                        newRHS.insert(rhs);
                    }
                }
                P[p.first] = newRHS;
            }
        }
    }
    N = usable;
}

void CFG::removeInaccessible() {
    set<string>accessible;
    accessible.insert(S); //the start symbol is always accessible
    for (auto rhs : P[S]) {
        for (string s : rhs) {
            if (N.find(s) != N.end()) {
                //if we found a non-terminal in a rhs, it is accessible
                accessible.insert(s);
            }
        }
    }
    bool modified = true;
    while (modified) {
        modified = false;
        for (auto a : accessible) {
            for (auto rhs : P[a]) {
                for (string s : rhs) {
                    if (N.find(s) != N.end() && accessible.find(s) == accessible.end()) {
                        //if we found a non-terminal in a rhs and it isn t in accessible already, we add it
                        accessible.insert(s);
                        modified = true;
                    }
                }
            }
        }
    }
    for (auto n : N) {
        if (accessible.find(n) == accessible.end()) {
            //if n in inaccessible
            P.erase(n);//we remove any production with n on the lhs
        }
    }
    N = accessible;
}

bool CFG::hasLambda() {
    for (auto p : P) {
        for (auto rhs : p.second) {
            for (string s : rhs) {
                if (s == "#" && p.first != S) {
                    return true;
                }
            }
        }
    }
    return false;
}

#pragma endregion